# Rutgers 选课架构调整提案原文

```text
【课程筛选与通知架构改进方案
静态前端筛选方案的问题回顾
原方案采用纯前端加载大 JSON 文件筛选的架构（方案B），即由后端定期抓取 Rutgers SOC 数据并生成 courses.json，前端在浏览器一次性加载20–40MB的课程数据并完成多条件筛选，通知则通过云函数轮询触发[1][2]。这一方案曾被认为在性能和扩展性上占优，借鉴了 QuACS 等开源项目的思路，即“所有课程筛选逻辑在浏览器完成，确保性能与可扩展性”[3]。静态站点托管成本低，前端筛选本地运行避免服务器瓶颈[4]，满足高并发和零登录需求[2]。
然而，随着支持多学期、多校区数据，courses.json 体积达数十MB，全量加载造成初始加载缓慢和内存占用过高。尽管原方案通过虚拟列表、Web Worker 等减缓前端性能风险[5]，但在低端设备或移动端上，大数据量仍可能导致明显卡顿。另一方面，通知功能依赖前端发起订阅请求，后台云函数依据订阅轮询开放席位[6]——这种分离式架构导致数据源和逻辑分散：前端和通知各自维护一份课程数据（JSON 与云函数内存），增量更新困难且存在冗余。综上，原方案中与前端静态筛选、大 JSON 数据、前端触发订阅相关的任务在现状下已不适配，亟需调整。
现有 record.json 中以下任务明显与旧架构强绑定，需要评估更改：
•T-20251113-act-001-soc-json-scraper – “静态 JSON 生成脚本”[7]：目前设计为批量抓取课程数据后生成静态 JSON 文件供前端使用。随着架构转变，此任务的输出形式需要改变（不再直接产出JSON给前端）。抓取逻辑仍有用，但应改为写入本地数据库而非输出单一大文件。
•T-20251113-act-002-frontend-filter-mvp – “基于静态 JSON 的课程列表与多维筛选”[8]：这是纯前端筛选实现，对应旧方案核心。由于前端不再预加载整个 JSON，此任务需重构实现方式。UI 筛选需求依旧，但数据来源应改为通过本地轻量接口按需查询获取，不再由浏览器直接遍历全量数据。
•T-20251113-act-003-mail-notify-function – “邮件通知云函数”[6]：原定通过云函数定时查询 openSections 接口监测已订阅课程开放并发邮件。新目标是每个部署环境独立运行通知逻辑，因此不再部署集中式云函数。本任务需要转换为本地后台服务/进程（如常驻任务或定时器）执行相同功能。前端触发订阅、数据监测和邮件发送都将在本地完成，而非依赖云端函数。
•(可能) 前端订阅触发逻辑：虽然 record.json 未明确列出独立任务，订阅操作原方案假定通过前端调用后端接口（或直接写文件/库）实现[9]。在新架构下，需确保前端提供订阅/退订UI并调用本地API写入本地数据库。因此，隐含的前端订阅触发部分也需调整实现。
上述任务如果不调整，将与新架构目标冲突，故需要替换或重构其描述和实现方案。
新架构概述：本地数据库驱动的筛选与通知
 
新架构在每个部署环境中的组件交互示意：前端通过本地 API 查询 SQLite 数据，每个环境自带后台进程负责课程数据更新及通知发送。
为解决大 JSON 加载的问题，推荐采用本地数据库+轻量服务架构（类似方案A的思路）。每个部署实例（无论是作者维护的线上服务，还是学生本地运行的独立实例）都包含一套本地的结构化数据存储和相关逻辑，实现课程筛选与空位通知功能的融合。其核心思路如下：
•本地持久化数据库：选用嵌入式数据库（如 SQLite）或轻量键值库作为课程数据存储。SQLite 是合适的选择，因为它零配置、支持复杂查询、性能足以应对几千门课程筛选，并可直接嵌入前端项目部署[10]。课程的基础信息和实时容量状态将存于本地DB中，使数据成为单一可信源，同时支持局部更新和查询索引优化。
•前端-后端分离查询：前端仍提供丰富的筛选UI，但不再预先加载所有课程数据，而是在用户选择筛选条件时，通过本地API获取符合条件的数据子集。每个实例将运行一个轻量级服务（可以是嵌入到前端框架的本地HTTP服务器，或一个Node/Go/Python微服务）来接受前端请求，根据筛选条件查询本地数据库并返回结果。这样即使课程总量很大，也仅传输当前筛选需要的数据，减小前端负担。
•本地更新与通知进程：在每个部署环境中，后台有进程负责数据抓取更新和空位监测通知。例如，一个调度任务每日调用 Rutgers SOC API 更新本地数据库中的课程信息（可仅获取增量变动部分），另一个高频任务每30-60秒调用 openSections 接口获取所有开放的Section列表，并对比本地订阅记录触发邮件/Discord通知。由于所有这些运行在本地，同一数据源下完成判断，避免了原方案中云函数需要再获取课程详情或跨环境存储的问题，实现筛选逻辑与通知逻辑统一在一份数据上。
•增量数据更新：新的数据管道应支持按需更新。首次启动时可以全量抓取指定学期/校区课程写入数据库，此后每日或每隔几小时仅抓取变化（例如比较上次抓取结果，只更新新增或状态改变的课程）。这避免了每天重新生成整份JSON并下发，提高效率和及时性。SQLite等关系库可以通过UPSERT操作方便地更新变动记录。此外，也可考虑定期清理过期学期的数据，保持库体积可控。
•多平台通知支持：本地通知模块需要适应不同邮件服务/平台。由于不再有统一云端，可允许不同部署采用各自的邮件发送方式：如默认支持SendGrid API（需本地存储密钥），也支持通过SMTP发送（方便个人用户用自己邮箱配置），以提高灵活性[11]。代码上应设计接口封装邮件发送，实现多邮件服务平台兼容。Discord 通知同理，本地运行Discord Bot客户端，利用配置的token发送私信或频道消息。由于每个实例通知量相对有限，风险可控；仍需实现频率节制和错误重试机制[12][13]。
引入本地API服务层是必要的。前端与数据库的交互应通过REST/HTTP接口或本地函数调用进行，而非直接从浏览器访问数据库文件。考虑到部署环境多为网页应用，最可行的是运行一个嵌入式HTTP服务：例如在Electron应用中嵌入，也可以是在Node环境下同时托管前端和API。这一服务层负责接收前端筛选请求（如GET /api/courses?campus=NB&credits>=3...），查询SQLite并返回JSON数据；也提供订阅管理接口（如POST /api/subscribe写入订阅；DELETE /api/unsubscribe删除订阅）以及必要的状态接口。这样的设计清晰分离了前端展示和后端数据操作，便于维护契约和扩展功能[14][15]。本地服务层既可嵌入前端进程（如利用Next.js或React Node一体化框架），也可作为独立进程通过localhost接口通信。每个部署实例因此成为一个完整的自给自足系统，无需中心服务器协调。
任务结构调整方案
为支持每个部署环境自带本地数据库和服务，需要对现有任务进行重组和新增。整体上，将原先数据抓取→前端JSON筛选→云函数通知的链条，调整为数据抓取→本地DB存储→本地查询服务/API→前端UI筛选，以及并行的本地通知调度。具体任务结构调整建议如下：
•数据抓取与存储任务：扩展原有抓取脚本任务，使其不仅生成数据文件，更要初始化/更新本地数据库。可以改造T-20251113-act-001或新增任务负责数据库模式设计和数据导入逻辑。例如：新增任务「设计本地数据库模式与导入脚本」：定义课程、Section、订阅等表结构，修改抓取脚本将结果写入SQLite。接受标准调整为：在多学期/校区下成功创建数据库文件，数据完整性通过随机抽查验证（可参考原JSON生成验证标准）[16][17]。该任务确保每个环境都能方便地建立和更新自身的数据副本。
•前端筛选与数据接口任务：将原T-20251113-act-002-frontend-filter-mvp拆分或重构。一部分仍然是前端多维筛选UI实现，包括课程列表组件、过滤表单、周视图等（这些UI需求不变）。另一部分新增本地API接口开发任务，用于支持前端的数据查询需求。建议增加任务「实现本地课程查询API」：基于选择的数据库（如SQLite）实现若干REST接口，比如获取院系列表、按条件分页检索课程/Section等。需考虑支持前端所需的各种筛选字段为查询参数（标题/代码关键字、学分范围、院系、课程级别、是否有先修、核心代码、上课时间等，对应FR-01/02/03要求[18]）。验收标准可定义为前端提供若干组合筛选请求，API 在毫秒级返回正确结果，数据格式符合前端渲染需要。前端任务则修改为调用这些API获取数据并渲染，而不假定数据已全部在内存。此调整实现每次筛选只获取必要的数据片段，降低前端负载。
•订阅管理与通知任务：重构原通知相关任务为本地模式。T-20251113-act-003-mail-notify-function需要修改为本地邮件通知服务实现。可将其拆分成两项子任务：一是「订阅管理与存储」，实现前端订阅UI和后端接口，将用户的Email/Discord标识和所订阅课程Section存入本地数据库（原任务的schemas/subscription.json将转为数据库表）[19]；二是「本地空位轮询与通知」，实现常驻任务定期检查课余量变化并发送通知。这部分沿用原Acceptance对时延和可靠性的要求[20]（如平均延迟<30秒，幂等避免重复通知等），但运行环境由云函数改为本地进程。任务描述需更新云函数相关措辞，强调在本地环境触发通知逻辑。类似地，T-20251113-act-004-discord-notify-channel可以保留但改为在本地集成Discord机器人的发送功能，作为对邮件通知的扩展（依赖邮件通知模块完成后再做）[21]。这两个任务应共享对本地数据库的访问：通知任务读取订阅表和课程表，判断某Index从Closed变Open时，通过邮件/Discord API发送消息。需新增支持多邮件服务的实现：例如配置文件允许切换SendGrid或自有SMTP，代码通过不同适配器发送邮件[11]。可以考虑追加一个子任务专门处理邮件发送适配，例如「支持多邮件服务平台的发送模块」：验收标准为替换不同发信方式仍能成功发送通知邮件。
•部署与运行任务：T-20251113-act-006-deploy-docs-cicd 文档任务需要更新，描述新的架构部署步骤。应指导用户如何在本地安装和运行数据库及服务。例如：提供初始化数据库的指令、启动本地API服务和前端的命令（可能使用脚本同时启动两者）。由于架构从“静态前端+本地脚本”变为“前后端一体应用”，文档应介绍如何配置本地环境变量（如数据库文件路径、邮件服务API密钥、Discord token等），以及如何选择邮件发送方式等。验收标准也应增补：比如在Windows/Mac环境下验证用户按照README能成功运行本地服务并打开前端页面进行筛选和接收通知。CI/CD 部分亦需更新，以适应部署一个后端服务。例如，可建议使用 Docker 将前端和本地服务打包，用户一键运行容器即可启动完整服务，而非仅部署静态页面。[22][23]
通过上述调整，每个部署环境将具备完整独立的能力：既能提供网页UI供用户浏览筛选课程，又在后台持续保持课程数据最新并及时通知订阅者，无需依赖中心服务器。此外，本地数据库使我们可以轻松实现数据的一致性和增量更新，避免了JSON方案下前后端数据脱节的问题。
具体任务变更与新增清单
根据变更规模和影响，将对 record.json 中任务做如下分类调整：
需要大幅修改或废弃重写的任务
•T-20251113-act-001 封装 Rutgers SOC 数据抓取与静态 JSON 生成脚本 – 大改：保留其数据抓取功能，但取消“生成静态JSON”输出[7]。任务标题和summary应修改为“抓取 Rutgers SOC 数据并初始化本地数据库”。接受标准调整为验证SQLite等数据库文件内容覆盖所需字段而非JSON文件[16]。如有必要，可拆分出一个专门的数据库设计任务，以体现从纯文件转向数据库存储的关键变更。
•T-20251113-act-002 实现基于静态 JSON 的课程列表与多维筛选（MVP） – 重构实现：该任务名称和描述需更新，去除对“静态 JSON 前端加载”的假设[8]。建议改名为“实现课程列表与多维筛选（基于本地查询API）”，summary说明前端通过调用本地API获取数据，多维筛选逻辑部分下放数据库查询。Acceptance标准修改：仍要求提供课程完整列表和多条件筛选UI，但响应性能可分为后端查询+前端渲染两部分考量（总体保持<0.5秒级）[24]，并确保与实际数据一致性。原任务不需要废弃，但实现方式改动非常大，可以认为旧方案“静态加载筛选”已放弃，重新实现同等功能。
•T-20251113-act-003 设计并上线基于 SOC openSections 的邮件通知云函数 – 重写：任务目标改为本地邮件通知服务。标题可改为“实现课程空位邮件通知功能（本地定时任务）”。summary需删除“云函数”措辞，改为描述本地进程如何轮询openSections接口并发送邮件通知[6]。Acceptance保持对通知及时性的要求，但强调在本地环境测得。如原任务拆为订阅管理和通知发送两个部分实现，也可将订阅相关内容单列新任务。总之，原云函数方案作废，以本地服务取代。
•（隐含）前端订阅触发逻辑 – 替换：虽然没有单列任务，但旧架构下可能假定通过前端直接写文件或调用云端API来保存订阅。新架构中，这一逻辑应包含在本地API任务或通知任务中。需要确保在任务描述中，把用户订阅操作接入本地数据库的流程记录清楚，例如在T-003的新描述中说明“提供订阅/退订接口，前端调用写入本地订阅表”，以取代任何原先前端直接触发通知的做法。
可保留但需调整描述的任务
•T-20251113-act-004 实现 Discord 通知通道并评估策略 – 保留功能，调整实现环境：该任务本质是在通知管道中增加Discord渠道，原依赖于邮件云函数完成后再集成[21]。新架构下依然实现Discord提醒，但作为本地通知模块的扩展。需修改summary和依赖描述，说明Discord Bot将在本地运行发送消息（而非云函数调用），并更新速率限制风险点（本地运行同样需考虑频率，只是不受云平台限制）[12]。Acceptance上大体不变[25]，验证方式改为本地环境下Bot给指定用户发信成功。此任务优先级和流程与之前相同（在邮件通知完成后进行），故保留但描述上去云端化。
•T-20251113-act-005 搭建前端 i18n 架构并完成中英文界面 – 基本不变：多语言支持任务与数据架构关系不大，故可保持原描述和验收。不过需要注意，由于引入本地API，一些错误信息或提示（如“后端服务未启动”之类）可能新增，需要在i18n中覆盖。但这些细节不影响任务主体，可在实施阶段添加。总体来说，本任务不受架构调整实质影响，保留即可[26]。
•T-20251113-act-006 编写并验证本地一键部署文档与辅助脚本 – 保留，调整细节：此任务需要与新方案同步更新内容，但使命仍是完善部署文档。应修改summary中对架构的描述，如将“静态前端 + 本地通知进程”改为“本地数据库驱动的前后端服务”[22]；Acceptance需加入如何初始化数据库、运行本地服务的步骤说明[27]。另外，还应在文档中阐明无需中央服务器、各环境独立运行的部署模式，并提供示例配置。CI/CD部分若涉及将前端部署到Pages等，需要调整为使用容器或Serverful平台部署（因为纯静态托管无法运行数据库服务）。这些调整属描述层面的改动，任务本身保留但需补充新的安装运行要点。
新增的任务/子任务
(以下新增任务ID可根据项目约定编号，比如继续用20251113序列或新的日期。暂以逻辑名称描述。)
•任务：设计本地数据库模式与增量更新机制 – 类型: 技术设计/研发。概要：确定SQLite本地库的表结构（课程、Section、订阅等），实现每日课程数据增量更新策略。内容：编写脚本比较新旧数据集差异，只更新变动部分记录；确保更新过程中不影响正在进行的查询（必要时采用事务或临时表交换）。验收：模拟一天内部分课程状态变化，运行更新脚本后数据库成功反映更改且未丢失原有数据，更新耗时远小于全量重载。
•任务：实现本地课程查询 API 服务 – 类型: 编码开发。概要：基于嵌入式数据库，实现HTTP接口供前端按需获取课程数据。内容：选择轻量框架（如Express/FastAPI等）开发/api/courses等端点，支持查询参数过滤和结果分页；实现基础错误处理和性能优化（如建立索引）。验收：前端多种筛选组合请求能够得到正确的JSON响应；在1k+课程数据下，单次查询接口响应在几百毫秒内，承载并发请求能力符合预期（可模拟并发测试）。
•任务：实现订阅管理接口与本地存储 – 类型: 编码开发。概要：创建前端订阅UI和对应后端接口，将用户订阅意图保存到本地DB。内容：前端在课程Section列表项提供“订阅”按钮，调用POST /api/subscribe并携带课程标识和用户联系方式；后端接口校验并在订阅表记录条目；实现/api/unsubscribe用于退订。验收：在本地运行环境，用户通过前端成功订阅某课程后，本地数据库出现对应记录；触发退订操作后记录删除，并验证通知任务不再对已退订项发送通知。
•任务：本地空位轮询与通知发送 – 类型: 编码开发。概要：实现后台定时任务检查课程余量并发送通知邮件/Discord。内容：利用服务器语言的定时任务库（如 Node 的node-cron或Python的APScheduler）每隔固定时间调用Rutgers openSections API获取开放课程Index列表；将其与本地订阅表比对，对于新开放的订阅项，通过调用邮件发送模块/Discord API发送通知，然后标记避免重复发送。验收：模拟一个Section从Closed变Open的过程，确认本地任务在一个轮询周期内检测到并发送邮件；观察日志确保同一开放事件仅通知一次[20]；在短时间内频繁开关的情况，也没有多次重复通知（验证幂等处理）。另外，通过断网/异常模拟，验证任务能够在恢复后继续运行或记录错误不致崩溃。
•任务：邮件发送模块多平台支持 – 类型: 编码/配置。概要：增强邮件发送功能，支持更换不同邮件服务平台。内容：抽象出邮件发送接口，例如提供SendGrid实现和SMTP实现两个模块，通过配置选择；确保邮件内容格式一致（支持多语言模板），错误处理健壮。验收：更改配置使用不同服务（如SendGrid vs SMTP），均能成功发送测试邮件；在超出配额或网络错误时模块能重试或记录错误提示。此任务可作为通知任务的子任务或平行辅助任务，保证开源用户无需修改代码即可使用自己的邮件服务。
说明：上述新增任务有助于将原方案缺失的后端部分补足，使开发任务清单完整覆盖新架构下的功能点。例如，原record.json未细分订阅接口和增量更新，这些在新架构中是成功关键，故单列明确。
推荐方案总结
综合以上分析，推荐采用“前端 + 本地轻量服务 + 嵌入式数据库”的架构方案来取代最初的纯静态方案。此方案的架构示意如上图所示，各部署实例内部包含前端、API服务、本地数据库和后台任务四部分，实现数据维护、筛选查询与通知的一体化。[28][10]
数据库选型：建议使用 SQLite 作为本地数据存储后端。一方面，SQLite作为嵌入式关系库，性能可靠且无需独立安装服务，适合部署在各种环境（包括学生本地电脑）[10]。另一方面，SQL查询能力使实现复杂筛选变得简单，能够利用索引优化查询速度，从而满足课程多条件过滤的性能要求。同时SQLite数据文件易于分发和备份，体量上几十MB的数据也在可接受范围。对于追求更简单部署的场景，也可考虑纯文件型KV存储（如Lightning Memory-Mapped Database等），但在需要复杂查询时将不如SQLite方便。综合考虑，SQLite 最符合需求。
架构优势：新方案直接解决了加载大JSON的痛点——通过本地查询API按需取数，大幅降低前端初始化开销和内存占用。每个实例独立运作，无需中央服务器或云函数，提升了系统鲁棒性和隐私合规（用户数据不出本机）。增量更新机制保证数据同步实时且高效，避免反复全量抓取的浪费。筛选和通知使用同一数据源，消除了数据不一致和重复存储的问题，提高了可靠性。此外，本地服务层的引入为未来扩展提供了灵活性：后续若增加新筛选维度或功能，只需扩展本地API和数据库，不受限于浏览器性能；若需支持更多通知渠道（短信等），也可在本地集成相应SDK而不涉及复杂云部署。
对原有任务调整一览：经过本次架构调整，record.json 中原有6项任务除i18n外均有所修改。其中，关于静态JSON和前端筛选的任务（T-001, T-002）实现方式变动最大，需要重写描述和验收以匹配本地数据库方案；关于通知的任务（T-003, T-004）从云端迁移到本地执行，相应依赖和风险说明需更新；部署文档任务（T-006）需补充新的运行流程说明。我们列出了需大改的任务及调整要点，以及可保留但应修改的任务描述，确保开发队列与最新架构对齐。与此同时，新增了本地API、增量更新等关键任务，填补了原计划中未明确的环节。下面按变更粒度归纳了修改建议，供第7步编排执行：
•重大架构变更相关：重定义 T-001 数据抓取任务为数据库初始化更新脚本；重构 T-002 前端筛选任务为依赖本地API的数据展示；将 T-003 邮件通知改为本地服务实现。原方案中这些任务的核心目的保留，但实现路径全面调整，需要在任务标题、summary和acceptance中反映架构转向本地数据库的决策[8][6]。
•中等修改：调整 T-004 Discord 通知任务的实施环境说明，确保其建立在本地通知基础上运行；更新 T-006 部署文档任务，包含新的架构部署步骤和脚本。它们涉及描述层面的改动，工作量相对可控，保证文档与实现一致。
•新增任务补充：添加本地数据库设计/更新、查询API、订阅管理、轮询通知等任务条目，完善产品 backlog。特别是订阅管理和API服务，这两部分在原任务集中没有清晰体现，但对实现“本地独立运行”目标至关重要，应在计划中着重跟进。
以上方案在权衡了开发成本与用户体验后，能够更好地满足项目最初的目标。尽管放弃了完全无后端的静态模式，略微增加了各实例维护一个轻量服务的复杂度，但换来了对大规模数据的良好支持和系统独立性提升。原决策记录中被舍弃的方案A（动态后端）如今经过调整在每个环境小规模地实现，其开发和运维成本是可控的[10]。综合考虑，我们认为采取这一改进架构有助于项目长期稳定发展，建议据此更新任务规划并在Step 7中执行相应的record.json编辑。各项修改完成后，应再次评估所有FR/NFR需求是否得到满足，确保新架构下系统表现符合预期[18][20]。
________________________________________
[1] [2] [3] [9] [10] [14] [15] DR结论.md
file://file_000000007f0071f5b70d3d43eead23c0
[4] [5] [6] [7] [8] [11] [12] [13] [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] record.json
file://file_00000000617471fbbf0468f521c1b593
】
```
