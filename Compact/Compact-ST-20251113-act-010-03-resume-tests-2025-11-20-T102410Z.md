# Compact – ST-20251113-act-010-03-resume-tests (post-CR)

## Implemented facts
- Poller now persists per-campus checkpoints (`--checkpoint`, default `scripts/poller_checkpoint.json`) capturing term/campus, last poll time, snapshot hash, open count, and miss counters; checkpoints are loaded on startup with metrics hydrated.
- Exported checkpoint helpers (`loadCheckpointState`, `persistCheckpoint`, `hydrateMissCountersFromCheckpoint`) plus `applySnapshot` and `createStatements`; `main` guarded to allow imports.
- Poll outcome includes `openCount/snapshotHash/polledAt/misses`; `pollOnce` writes a checkpoint after each successful poll.
- Synthetic durability sim (`scripts/poller_resume_sim.ts`) runs 120 one-minute ticks with a restart after a missed heartbeat, seeding a temp DB; checkpoints written each tick.
- Report `reports/poller_durability.md` captures scenario, results, checkpoint design, runbook; record.json marks subtask done.

## Behavior / interface changes
- New CLI flag `--checkpoint <path>`; startup logs include checkpoint path and restoration per campus; metrics `lastOpenCount` restored from checkpoint.
- Checkpoint loading hardened per CR: accepts only mutable object for `campuses`; corrupted JSON now falls back to a fresh checkpoint with warning instead of crashing on writes.

## Self-test
- `npx tsx scripts/poller_resume_sim.ts` (prior to CR fix) → open at t=30m, close at t=81m immediately after restart (restored miss), reopen at t=100m; totals opened=2, closed=1, events=3, notifications=2.
- Post-CR validation change not re-run (defensive only).

## Risks / TODO
- Checkpoint write failures merely log; corrupted/missing files reset state (may delay closures by one debounce window). Need live run against real SOC/local DB to confirm end-to-end behavior.

## Code Review - ST-20251113-act-010-03-resume-tests - 2025-11-20T10:25:25Z

---review-start---
workers/open_sections_poller.ts
Comment on lines +355 to +359


        data: {
          version: 1,
          updatedAt: parsed.updatedAt ?? new Date().toISOString(),
          campuses: parsed.campuses,
        },


@chatgpt-codex-connector
chatgpt-codex-connector bot

P2 Badge Validate checkpoint structure before reuse

loadCheckpointState accepts any truthy parsed.campuses value and returns it as the active checkpoint data. If the checkpoint file is syntactically valid JSON but corrupted to something like { "version": 1, "campuses": "broken" }, this branch will treat the string as the campuses map. On the next poll persistCheckpoint tries to assign ctx.checkpoint.data.campuses[campus] = entry, which throws in strict mode and causes every poll attempt to fail instead of logging a warning and starting fresh. Validating that campuses is a mutable object (and falling back to an empty checkpoint when it is not) would keep the worker running when the checkpoint file is damaged.
---review-end---

## Code Review - ST-20251113-act-010-03-resume-tests - 2025-11-20T11:38:08Z

---review-start---
workers/open_sections_poller.ts
Comment on lines +352 to +354


    const campuses = parsed?.campuses;
    const validCampuses = campuses && typeof campuses === 'object' && !Array.isArray(campuses) ? campuses : null;
    if (parsed && parsed.version === 1 && validCampuses) {


@chatgpt-codex-connector
chatgpt-codex-connector bot

P2 Badge Warn when discarding malformed checkpoint

The new validation at loadCheckpointState (lines 352-354) rejects checkpoints whose campuses value is not an object, but when that happens the function falls through to emptyCheckpoint with no warning. If the checkpoint JSON is syntactically valid but corrupted (e.g., "campuses": "broken"), we now silently drop all saved miss counters and open counts on startup; operators get no signal that state was reset, leading to duplicate reopen notifications or missed debounce behavior after a restart. Emitting a warning before returning the empty checkpoint would preserve observability of this fallback.
---review-end---

## Code Review - ST-20251113-act-010-03-resume-tests - 2025-11-20T11:39:00Z

---review-start---
workers/open_sections_poller.ts
Comment on lines +352 to +354


    const campuses = parsed?.campuses;
    const validCampuses = campuses && typeof campuses === 'object' && !Array.isArray(campuses) ? campuses : null;
    if (parsed && parsed.version === 1 && validCampuses) {


@chatgpt-codex-connector
chatgpt-codex-connector bot

P2 Badge Warn when discarding malformed checkpoint

The new validation at loadCheckpointState (lines 352-354) rejects checkpoints whose campuses value is not an object, but when that happens the function falls through to emptyCheckpoint with no warning. If the checkpoint JSON is syntactically valid but corrupted (e.g., "campuses": "broken"), we now silently drop all saved miss counters and open counts on startup; operators get no signal that state was reset, leading to duplicate reopen notifications or missed debounce behavior after a restart. Emitting a warning before returning the empty checkpoint would preserve observability of this fallback.
---review-end---
